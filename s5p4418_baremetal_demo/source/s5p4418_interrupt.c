/*Interrupt Sources Description Table
 *********************************************
 *Interrupt Number-Source 	Description
 *	0 	MCUSTOP 	MCUSTOP interrupt
 *	1 	DMA0 		DMA0 interrupt
 *	2 	DMA1 		DMA1 interrupt
 *	3 	CLKPWR0 	CLKPWRPWR interrupt
 *	4 	CLKPWR1 	CLKPWRALIVE interrupt
 *	5 	CLKPWR2 	CLKPWRRTC interrupt
 *	6 	UART1 		UART1 interrupt
 *	7 	UART0 		UART0 interrupt
 *	8	UART2 		UART2 interrupt
 *	9 	UART3 		UART3 interrupt
 *	10 	UART4 		UART4 interrupt
 *	11 	RESERVED 	â€“
 *	12 	SSP0 		SSP0 interrupt
 *	13 	SSP1 		SSP1 interrupt
 *	14 	SSP2 		SSP2 interrupt
 *	15 	I2C0 		I2C0 interrupt
 *	16 	I2C1 		I2C1 interrupt
 *	17 	I2C2 		I2C2 interrupt
 *	18 	DEINTERLACE 	DEINTERLACE interrupt
 *	19 	SCALER 		SCALER interrupt
 *	20 	AC97 		AC97 interrupt
 *  	21 	SPDIFRX 	SPDIFRX interrupt
 *	22 	SPDIFTX 	SPDIFTX interrupt
 *	23	TIMER0 		TIMER0 interrupt
 *	24 	TIMER1 		TIMER1 interrupt
 *	25 	TIMER2 		TIMER2 interrupt
 *	26 	TIMER3 		TIMER3 interrupt
 *	27 	PWM0 		PWM0 interrupt
 *	28 	PWM1 		PWM1 interrupt
 *	29 	PWM2 		PWM2 interrupt
 *	30 	PWM3 		PWM3 interrupt
 *	31 	WDT 		WDT interrupt
 *	32 	MPEGTSI 	MPEGTSI interrupt
 *	33 	DISPLAYTOP0 	DISPLAYDUALDISPLAYPRIM interrupt
 *	34 	DISPLAYTOP1 	DISPLAYDUALDISPLAYSECOND interrupt
 *	35 	DISPLAYTOP2 	DISPLAYRESCONV interrupt
 *	36 	DISPLAYTOP3 	DISPLAYHDMI interrupt
 *	37 	VIP0 		VIP0 interrupt
 *	38 	VIP1 		VIP1 interrupt
 *	39 	MIPI 		MIPI interrupt
 *	40 	3D GPU 		3D GPU interrupt
 *	41 	ADC 		ADC interrupt
 *	42 	PPM 		PPM interrupt
 *	43 	SDMMC0 		SDMMC0 interrupt
 *	44 	SDMMC1 		SDMMC1 interrupt
 *	45 	SDMMC2 		SDMMC2 interrupt
 *	46 	CODA9600 	CODA960HOST interrupt
 *	47 	CODA9601 	CODA960JPG interrupt
 *	48 	GMAC 		GMAC interrupt
 *	49 	USB20OTG 	USB20OTG interrupt
 *	50 	USB20HOST 	USB20HOST interrupt
 *	51 	N/A 		N/A
 *	52 	N/A 		N/A
 *	53 	GPIOA 		GPIOA interrupt
 *	54 	GPIOB 		GPIOB interrupt
 *	55 	GPIOC 		GPIOC interrupt
 *	56 	GPIOD 		GPIOD interrupt
 *	57 	GPIOE 		GPIOE interrupt
 *	58 	CRYPTO 		CRYPTO interrupt
 *	59 	PDM 		PDM interrupt
 *	60 	N/A 		N/A
 *	61 	N/A 		N/A
 *	62 	N/A 		N/A
 *	63 	N/A 		N/A
 */



/*
9.4 Programming sequence

The following procedure shows the sequence for the IRQ interrupt flow:
1.An IRQ interrupt occurs.
2.The ARM processor branches to the IRQ interrupt vector
3.Stack the workspace so that IRQ interrupts can be re-enabled later.
4.Perform a dummy read to the VICADDRESS Register to set up priority status control in the VIC.
5.Read the VICIRQSTATUS Register and determine which interrupt sources have to be service.
6.Execute the ISR. At the beginning of the ISR, the interrupt of the processor can be re-enabled so that a higher priority interrupt can be serviced.
7.Clear the requesting interrupt in the peripheral, or write to the VICSOFTINTCLEAR Register if the request was generated by a software interrupt.
8.Disable the interrupt on the processor and restore the workspace.
9.Write to the VICADDRESS Register. This clears the respective interrupt in the internal interrupt priority hardware.
10.Return from the interrupt. This re-enables the interrupts
*/
#include"../include/s5p4418_interrupt.h"
void s5p4418_IRQ_Init(VIC_TypeDef* VICx,VICVEC_TypeDef* VICx_VEC,VIC_TypeDef* VICy,VICVEC_TypeDef* VICy_VEC)
{
	/* VIC to core, pass through GIC */
	GICC_CTLR = 0;
	/* Select irq mode */
	VICx->VIC_INTSELECT = 0x00000000;
	VICy->VIC_INTSELECT = 0x00000000;
	/* Disable all interrupts */
	VICx->VIC_INTENABLE = 0x00000000;
	VICy->VIC_INTENABLE = 0x00000000;
	/* Clear all interrupts */
	VICx->VIC_INTENCLEAR = 0xFFFFFFFF;
	VICy->VIC_INTENCLEAR = 0xFFFFFFFF;
	/* Clear all irq status */
	VICx->VIC_IRQSTATUS = 0x00000000;
	VICy->VIC_IRQSTATUS = 0x00000000;	
	/* Clear all fiq status */
	VICx->VIC_FIQSTATUS = 0x00000000;
	VICy->VIC_FIQSTATUS = 0x00000000;
	/* Clear all software interrupts */
	VICx->VIC_SOFTINTCLEAR = 0xFFFFFFFF;
	VICy->VIC_SOFTINTCLEAR = 0xFFFFFFFF;
	/* Set vic address to zero */	
	VIC0_ADDRESS = 0x00000000;
	VIC1_ADDRESS = 0x00000000;
	/* UART0  vectored interrupt priority level 15 (lowest) */
	VICx_VEC->VIC_VECPRIORITY7 = 0x0F;	
	VICx_VEC->VIC_VECTADDR7 = (uint32_t)UART_IRQHandler;
	/* Enable UART0 vic interrupt */
	VICx->VIC_INTENABLE |= 0x80; 
}


void do_irqs(void)
{	
	void (*irq_func)();	
	uint32_t temp;
	/* Read vector interrupt controller's irq status */
	if((VIC0->VIC_IRQSTATUS) && 0x80)
	{
		/* Read interrupt server function address */
		irq_func = (void(*)())VIC0_ADDRESS;
		/* Handle interrupt server function */
		(*irq_func)();
		/* Clear software interrupt */
		VIC0->VIC_SOFTINTCLEAR |= 0x80;
		/* Set vic address to zero */
		VIC0_ADDRESS = 0x00000000;
	}
}



